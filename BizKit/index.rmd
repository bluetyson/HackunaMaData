---
title: "BizKit 1.0"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
runtime: shiny
---

```{r setup, include=FALSE}
# NOTE: SET YOUR WORKING DIRECTORY HERE (LOCATION OF REPO)
# setwd()
if (!require(rmarkdown)) {
  install.packages("rmarkdown")
}
if (!require(flexdashboard)) {
  install.packages("flexdashboard")
}
if (!require(shiny)) {
  install.packages("shiny")
}
if (!require(leaflet)) {
  install.packages("leaflet")
}
if (!require(highcharter)) {
  install.packages("highcharter")
}
if (!require("rgdal")) {
  install.packages("rgdal")
}
if (!require(sp)) {
  install.packages("sp")
}
if (!require(maps)) {
  install.packages("maps")
}
if (!require(ggmap)) {
  install.packages("ggmap")
}
if (!require(maptools)) {
  install.packages("maptools")
}
if (!require(data.table)) {
  install.packages("data.table")
}
if (!require(tidyr)) {
  install.packages("tidyr")
}
if (!require(treemap)) {
  install.packages("treemap")
}


library(rmarkdown)

library(rmarkdown)
library(flexdashboard)
library(shiny)
library(leaflet)
library(highcharter)
library("rgdal")
library(sp)
library(maps)
library(ggmap)
library(maptools)
library(data.table)
library(tidyr)

centroids <- read.csv(file="data/csv/suburb_centroids.csv", header=TRUE, sep=",")
df.census.age.profile = read.csv(file="data/census/processed/df.age.profile.csv", header=TRUE, sep=",")
df.census.weekly.income = read.csv(file="data/census/processed/df.weekly.income.csv", header=TRUE, sep=",")
df.census.family.comp = read.csv(file="data/census/processed/df.family.composition.csv", header=TRUE, sep=",")
```

Inputs {.sidebar}
-----------------------------------------------------------------------

Microarray data matrix for 80 experiments with Saccharomyces Cerevisiae
organism extracted from R's `biclust` package.

Sebastian Kaiser, Rodrigo Santamaria, Tatsiana Khamiakova, Martin Sill, Roberto
  Theron, Luis Quintales, Friedrich Leisch and Ewoud De Troyer. (2015). biclust:
  BiCluster Algorithms. R package version 1.2.0.
  http://CRAN.R-project.org/package=biclust
  
```{r}
latitude.max <- max(centroids$lat)
latitude.min <- min(centroids$lat)
longitude.max <- max(centroids$long)
latitude.min <- max(centroids$long)
# Rate at which to flag high download traffic
# Rate at which to flag high download traffic
selectInput("clusterNum", label = h3("Cluster number"), 
            choices = list("1" = 1, "2" = 2, "3" = 3, "4" = 4, "5" = 5), 
            selected = 1)

```

Row
-----------------------------------------------------------------------

```{r}
## Read suburbs data
url <- "data/geoJSON/Suburbs.geojson"
res <- readOGR(url, layer="OGRGeoJSON" ,verbose = FALSE)

## Subset data for Adelaide area only
url <- "data/csv/Adelaide_Zips.csv"
adelaide.zips <- read.csv(url)
unique.zips <- unique(adelaide.zips$Post.Code)

match.indices <- which(res$POSTCODE %in% unique.zips)
subset.data <- res[na.omit(match.indices),]

## Read bike lane data
tkml <- readOGR("data/KMZ/bike_routes.kml", "templayer0", verbose=FALSE)

## Major and minor roads
major.roads <- readOGR("data/KMZ/major_roads.kml", "MajorRoads_Layer", verbose=FALSE)
minor.roads <- readOGR("data/KMZ/minor_roads.kml", "MinorRoads_Layer", verbose=FALSE)


## Initialize color bins for legend
testvector <- c(1:length(subset.data))
bins <- c(0, 100, 200, 300, 400, 500, 600, Inf)
pal <- colorBin("YlOrRd", domain = testvector, bins = bins)

output$map <- renderLeaflet({

  x <- leaflet() %>%
    addTiles() %>%
    addMarkers(data = centroids, 
               lng = centroids$long, 
               lat = centroids$lat, 
               layerId = ~centroids$id, 
               popup = ~centroids$suburb, 
               clusterOptions = markerClusterOptions()) %>%
    addPolygons(data = subset.data) %>%
    addPolygons(
      data = subset.data,
      fillColor = ~pal(testvector),
      weight = 2,
      opacity = 1,
      color = "white",
      dashArray = "3",
      fillOpacity = 0.7) %>%
    addPolylines(data = major.roads, color="red") %>%
    addPolylines(data = minor.roads, color="salmon") %>%
    addPolylines(data = tkml, color="green")
  })

leafletOutput('map')  

```

Row
-----------------------------------------------------------------------

```{r}
yelp.get <- dget("yelp_api_call.R")

click_marker <- eventReactive(input$map_marker_click, {

  x <- input$map_marker_click
  # centroids[centroids$id == input$map_market_click, ]
  # yelp.data <<- yelp.get(input$map_marker_click, "Australia")

  return(x$id)

})

data_for_chart <- reactive({

  return(centroids[centroids$id == click_marker(), ])

})

# age profile
output$chart <- renderHighchart({

  df.census.age.profile.postc = subset (df.census.age.profile, subset = POA_CODE_2016 == data_for_chart()$zipcode)
  
  df.census.age.profile.postc = 
                      df.census.age.profile.postc %>%
                        gather(class, total, -POA_CODE_2016)
  
  highchart() %>%
    hc_chart(type = 'pie') %>%
    hc_title(text = "Age Profile") %>% 
    hc_add_series_labels_values(df.census.age.profile.postc$class,df.census.age.profile.postc$total)

})

highchartOutput('chart')

# weekly income
output$chart_income <- renderHighchart({

  df.census.weekly.income.postc = subset (df.census.weekly.income, subset = POA_CODE_2016 == data_for_chart()$zipcode)
  
  df.census.weekly.income.postc = 
                      df.census.weekly.income.postc %>%
                        gather(class, total, -POA_CODE_2016)
  
  highchart() %>%
    hc_chart(type = 'pie') %>%
    hc_title(text = "Weekly Income") %>%
    hc_add_series_labels_values(df.census.weekly.income.postc$class,df.census.weekly.income.postc$total)

})

highchartOutput('chart_income')

# family comp
output$chart_fam <- renderHighchart({

  df.census.family.comp.postc = subset (df.census.family.comp, subset = POA_CODE_2016 == data_for_chart()$zipcode)
  
  df.census.family.comp.postc = 
                      df.census.family.comp.postc %>%
                        gather(class, total, -POA_CODE_2016)
  
  highchart() %>%
    hc_chart(type = 'pie') %>%
    hc_title(text = "Family Composition") %>%
    hc_add_series_labels_values(df.census.family.comp.postc$class,df.census.family.comp.postc$total)
  
})

highchartOutput('chart_fam')

##### IMPORT YELP DATA ######
# yelp.get <- dget("yelp_api_call.R")
# yelp.data <- yelp.get(5000,"Australia")
# cats <- unlist(yelp.data$category)
# count.cats <- table(cats)
# count.data <- data.table(category=row.names(count.cats),
#                          count=as.numeric(count.cats))

library(viridisLite)
library(treemap)

cols <- viridis(6)
cols <- substr(cols, 0, 7)

# yelp.get <- dget("yelp_api_call.R")
# yelp.data <- yelp.get(data_for_chart()$zipcode,"Australia")
# cats <- unlist(yelp.data$category)
# count.cats <- table(cats)
# count.data <- data.table(category=row.names(count.cats),
#                          count=as.numeric(count.cats))
# 
# tm <- treemap(count.data[count>1], index = "category",
#               title = "",
#               vSize = "count", vColor = "count",
#               type = "value", palette = rev(viridis(6)))

output$chart2 <- renderHighchart({
yelp.get <- dget("yelp_api_call.R")
yelp.data <- yelp.get(data_for_chart()$zipcode,"Australia")
cats <- unlist(yelp.data$category)
count.cats <- table(cats)
count.data <- data.table(category=row.names(count.cats),
                         count=as.numeric(count.cats))

tm <- treemap(count.data, index = "category",
              title = "",
              vSize = "count", vColor = "count",
              type = "value", palette = rev(viridis(6)))

  highchart() %>%
    hc_add_series_treemap(tm, allowDrillToNode=TRUE, layoutAlgorithm="squarified") 
  #   hc_chart(type = "treemap") %>%
  #   hc_size(count.data$count) %>%
  #   hc_colorAxis() %>%
  #   hc_xAxis(categories = count.data$category) %>%
  #   hc_add_series(count.data$count, name = "category", showInLegend = FALSE,
  #                 dataLabels = list(enabled = TRUE, format = '{point.value}')) 
  
})

highchartOutput('chart2')



```